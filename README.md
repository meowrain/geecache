# LRU 实现图

![](https://blog.meowrain.cn/api/i/2025/03/19/9qnWlL1742359834808556298.avif)


# singleflight防止缓存击穿

## 什么是缓存击穿？
缓存击穿：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。

## singleflight主要实现了什么？

在串行请求的情况下，`fn` 函数会执行多次。这是因为 `singleflight` 的设计初衷是处理并发请求的合并，而不是串行请求的优化。

具体来说：

1. **串行请求场景**：
   - 第一个请求进入 `Do` 方法时，会创建 `call` 并执行 `fn`。
   - 当第一个请求完成后，`call` 会被从 `map` 中删除。
   - 第二个请求进入时，由于 `map` 中已经没有对应的 `call`，会再次创建新的 `call` 并执行 `fn`。
   - 以此类推，每个串行请求都会独立执行 `fn`。

2. **并发请求场景**：
   - 多个请求同时进入 `Do` 方法时，只有第一个请求会创建 `call` 并执行 `fn`。
   - 后续请求会等待第一个请求的结果，而不会重复执行 `fn`。

因此，`singleflight` 的核心作用是合并并发请求，而不是缓存结果。如果你希望在串行请求时也能复用结果，需要在 `singleflight` 的基础上增加缓存机制，或者使用其他缓存方案（如 `sync.Map` 或 `LRU Cache`）来存储 `fn` 的执行结果。